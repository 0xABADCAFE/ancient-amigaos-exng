//****************************************************************************//
//**                                                                        **//
//** File:         include/guilib/guibase.hpp                               **//
//** Description:  Abstract GUI Base definitions                            **//
//** Comment(s):                                                            **//
//** Library:      guilib                                                   **//
//** Created:      2003-03-04                                               **//
//** Updated:      2003-03-04                                               **//
//** Author(s):    Karl Churchill                                           **//
//** Note(s):                                                               **//
//** Copyright:    (C)1996-2003, eXtropia Studios                           **//
//**               Serkan YAZICI, Karl Churchill                            **//
//**               All Rights Reserved.                                     **//
//**                                                                        **//
//****************************************************************************//

#ifndef _EXTROPIA_GUILIB_GUIBASE_HPP
#define _EXTROPIA_GUILIB_GUIBASE_HPP

#include <xbase.hpp>
#include <iolib/inpdevs.hpp>
#include <gfxlib/draw.hpp>
#include <utilitylib/list.hpp>

#define S_XYDXDY sint16 x, sint16 y, sint16 dx, sint16 dy

class GUIObject;

////////////////////////////////////////////////////////////////////////////////
//
//  GUIBase
//
//  Topmost handler, interfaces directly with iolib/InputFocus system.
//
////////////////////////////////////////////////////////////////////////////////

class GUIBase : public InputFocus {
  private:
    static GUIObject* active;
    GUIObject*        root;
    uint32            state;

    enum {
      BROADCASTPASSIVE  = 0x00000001
    };

    GUIObject*  find(S_XY);

  protected:
    // overridden from InputFocus
    void keyPressNonPrintable(I_SRC, Key::CtrlKey code);
    void keyReleaseNonPrintable(I_SRC, Key::CtrlKey code);
    void keyPressPrintable(I_SRC, sint32 ch);
    void keyReleasePrintable(I_SRC, sint32 ch);
    void mousePress(I_SRC, uint32 code);
    void mouseRelease(I_SRC, uint32 code);
    void mouseMove(I_SRC, S_XYDXDY);
    void mouseDrag(I_SRC, S_XYDXDY, uint32 s);
    void mouseScroll(I_SRC, S_XY);

  public:
    void setRoot(GUIObject* o)    { root = o; }
    GUIObject*        getRoot()    { return root; }
    static GUIObject*  getActive()  { return active; }
    static void        setActive(GUIObject* o);

    void              enablePassive() { state |= BROADCASTPASSIVE; }
    void              disablePassive() { state &= ~BROADCASTPASSIVE; }

    GUIBase();
    ~GUIBase();
};


////////////////////////////////////////////////////////////////////////////////
//
//  GUIListener
//
//  Base interface for any object wishing to process events generated by a
//  GUIObject.
//
////////////////////////////////////////////////////////////////////////////////

class GUIListener {
  friend class GUIObject;
  protected:
    virtual void handleGUIEvent(GUIObject* o) = 0;
};


////////////////////////////////////////////////////////////////////////////////
//
//  GUIObject
//
//  Base interface for any GUI control. The GUIObject interface is essentially
//  an extended InputFocus. As well as providing virtual handlers for raw input,
//  there are a second set of equivalent handlers for passive response to input.
//  Each GUIObject maintains a list of children GUIObjects and GUIListeners.
//
////////////////////////////////////////////////////////////////////////////////


class GUIObject : public Rect {
  friend class GUIBase;
  private:
    static uint32  nextID;
    uint32 myID;

    RefList<GUIListener>  listeners;
    RefList<GUIObject>    children;
    GUIObject*            parent;
    uint32                state;
    uint32                aFilter;    // See IFilter
    uint32                pFilter;    // See IFilter
    uint32                zOrder;
    sint32                eventType;  // Subclass defined value

    // Recursive find
    GUIObject*            recFindHit(S_XY, GUIObject* curr);

    // Recursive handlers, each invoking the passive handler for itself and
    // its children.
    void recKeyPressNP(Key::CtrlKey code);
    void recKeyReleaseNP(Key::CtrlKey code);
    void recKeyPress(sint32 ch);
    void recKeyRelease(sint32 ch);
    void recMousePress(S_XY, uint32 code);
    void recMouseRelease(S_XY, uint32 code);
    void recMouseMove(S_XYDXDY);
    void recMouseDrag(S_XYDXDY, uint32 s);
    void recMouseScroll(S_XY);


  protected:
    enum { // Control states
      ENABLED              = 0x00000001,
      ACTIVE              = 0x00000002
    };

    enum {
      // Common GUIObject event types use negative values
      // Object specific values (after determining the object type)
      // are regular enumerations starting at 1
      GE_ACTIVATED        = -1,
      GE_DEACTIVATED      = -2,
      GE_ENABLED          = -3,
      GE_DISABLED          = -4
    };

    // Input filters. The definitons used are taken directly from those
    // defined by InputFocus.

    bool getActiveResponses(uint32 r)    { return (aFilter & r)!=0; }
    bool getPassiveResponses(uint32 r)  { return (pFilter & r)!=0; }
    void setActiveResponses(uint32 r)    { aFilter |= r; }
    void clrActiveResponses(uint32 r)    { aFilter &= ~r; }
    void togActiveResponses(uint32 r)    { aFilter ^= r; }
    void setPassiveResponses(uint32 r)  { pFilter |= r; }
    void clrPassiveResponses(uint32 r)  { pFilter &= ~r; }
    void togPassiveResponses(uint32 r)  { pFilter ^= r; }

    // Collision detection. Default is defined as both x and y are inside
    // Rect bounds
    virtual  bool coordHit(S_XY);

    // General event handlers
    virtual void setEnabled()    {};
    virtual void setDisabled()  {};
    virtual void setActive()    {};
    virtual void setInactive()  {};

    // Input event handlers for when this is the active object
    virtual void keyPressNP(Key::CtrlKey code)    {}
    virtual void keyReleaseNP(Key::CtrlKey code)  {}
    virtual void keyPress(sint32 ch)              {}
    virtual void keyRelease(sint32 ch)            {}
    virtual void mousePress(S_XY, uint32 code)    {}
    virtual void mouseRelease(S_XY, uint32 code)  {}
    virtual void mouseMove(S_XYDXDY)              {}
    virtual void mouseDrag(S_XYDXDY, uint32 s)    {}
    virtual void mouseScroll(S_XY)                {}

    // Input event handlers for when this is not the active object
    virtual void passKeyPressNP(Key::CtrlKey code)    {}
    virtual void passKeyReleaseNP(Key::CtrlKey code)  {}
    virtual void passKeyPress(sint32 ch)              {}
    virtual void passKeyRelease(sint32 ch)            {}
    virtual void passMousePress(S_XY, uint32 code)    {}
    virtual void passMouseRelease(S_XY, uint32 code)  {}
    virtual void passMouseMove(S_XYDXDY)              {}
    virtual void passMouseDrag(S_XYDXDY, uint32 s)    {}
    virtual void passMouseScroll(S_XY)                {}

    //
    void setEventType(uint32 e)        { eventType = e; }
    // GUIListener notification - passes this GUIObject to every
    // listener registered with it. Should be the last function
    // called as part of any specific GUIObject derived class'
    // input event handling.
    void updateListeners();

  public:
    void    enable()                  { state |= ENABLED; setEnabled(); }
    void    disable()                  { state &= ~ENABLED; setDisabled(); }
    void    activate()                { state |= ACTIVE; setActive(); }
    void    deactivate()              { state &= ~ACTIVE; setInactive(); }

    bool    enabled()                  { return (state & ENABLED)!=0; }
    bool    active()                  { return (state & ACTIVE)!=0; }

    bool    addChild(GUIObject* o);
    bool    removeChild(GUIObject* o);
    bool    addListener(GUIListener* l);
    bool    removeListener(GUIListener* l);

    sint32  getEventType()  { return eventType; }
    uint32  getID()          { return myID; }

  protected:
    GUIObject();
    GUIObject(S_XYWH, uint32 z, uint32 act, uint32 inact);

  public:
    virtual ~GUIObject();
};

////////////////////////////////////////////////////////////////////////////////
//
//  Renderable
//
//  Base interface for GUI rendering, provided seperately since some application
//  may wish to define its own custom rendering (using non exng resources).
//
//  Subclass must define sint32 render(Draw2D*) method. It is safe to assume
//  that the render() method is called with all due checks/locks in place, so
//  the implementor simply has to focus on defining the required action.
//
////////////////////////////////////////////////////////////////////////////////


class Renderable
{
  private:
    Draw2D*  gfx;

  protected:
    // Subclass must define render()
    virtual sint32 render(Draw2D* g) = 0;

  public:
    sint32  draw(Draw2D* g);
    sint32  draw()              { return draw(gfx); }
    void    setDraw(Draw2D* g)  { gfx = g; }
    Draw2D*  getDraw()            { return gfx; }

  protected:
    Renderable() : gfx(0) {}
    Renderable(Draw2D* g) : gfx(g) {}
};


#endif
